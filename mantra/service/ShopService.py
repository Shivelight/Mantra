#
# Autogenerated by Thrift Compiler ()
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:asyncio
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException
from thrift.protocol.TProtocol import TProtocolException
import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.TAsyncio import TAsyncioApplicationException


class Client(object):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    async def buyCoinProduct(self, paymentReservation):
        """
        Parameters:
         - paymentReservation
        """
        await self.send_buyCoinProduct(paymentReservation)
        (await self.recv_buyCoinProduct())

    async def send_buyCoinProduct(self, paymentReservation):
        self._oprot.writeMessageBegin('buyCoinProduct', TMessageType.CALL, self._seqid)
        args = buyCoinProduct_args()
        args.paymentReservation = paymentReservation
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_buyCoinProduct(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = buyCoinProduct_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    async def buyFreeProduct(self, receiverMid, productId, messageTemplate, language, country, packageId):
        """
        Parameters:
         - receiverMid
         - productId
         - messageTemplate
         - language
         - country
         - packageId
        """
        await self.send_buyFreeProduct(receiverMid, productId, messageTemplate, language, country, packageId)
        (await self.recv_buyFreeProduct())

    async def send_buyFreeProduct(self, receiverMid, productId, messageTemplate, language, country, packageId):
        self._oprot.writeMessageBegin('buyFreeProduct', TMessageType.CALL, self._seqid)
        args = buyFreeProduct_args()
        args.receiverMid = receiverMid
        args.productId = productId
        args.messageTemplate = messageTemplate
        args.language = language
        args.country = country
        args.packageId = packageId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_buyFreeProduct(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = buyFreeProduct_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    async def buyMustbuyProduct(self, receiverMid, productId, messageTemplate, language, country, packageId, serialNumber):
        """
        Parameters:
         - receiverMid
         - productId
         - messageTemplate
         - language
         - country
         - packageId
         - serialNumber
        """
        await self.send_buyMustbuyProduct(receiverMid, productId, messageTemplate, language, country, packageId, serialNumber)
        (await self.recv_buyMustbuyProduct())

    async def send_buyMustbuyProduct(self, receiverMid, productId, messageTemplate, language, country, packageId, serialNumber):
        self._oprot.writeMessageBegin('buyMustbuyProduct', TMessageType.CALL, self._seqid)
        args = buyMustbuyProduct_args()
        args.receiverMid = receiverMid
        args.productId = productId
        args.messageTemplate = messageTemplate
        args.language = language
        args.country = country
        args.packageId = packageId
        args.serialNumber = serialNumber
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_buyMustbuyProduct(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = buyMustbuyProduct_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    async def checkCanReceivePresent(self, recipientMid, packageId, language, country):
        """
        Parameters:
         - recipientMid
         - packageId
         - language
         - country
        """
        await self.send_checkCanReceivePresent(recipientMid, packageId, language, country)
        (await self.recv_checkCanReceivePresent())

    async def send_checkCanReceivePresent(self, recipientMid, packageId, language, country):
        self._oprot.writeMessageBegin('checkCanReceivePresent', TMessageType.CALL, self._seqid)
        args = checkCanReceivePresent_args()
        args.recipientMid = recipientMid
        args.packageId = packageId
        args.language = language
        args.country = country
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_checkCanReceivePresent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = checkCanReceivePresent_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    async def getActivePurchases(self, start, size, language, country):
        """
        Parameters:
         - start
         - size
         - language
         - country
        """
        await self.send_getActivePurchases(start, size, language, country)
        return (await self.recv_getActivePurchases())

    async def send_getActivePurchases(self, start, size, language, country):
        self._oprot.writeMessageBegin('getActivePurchases', TMessageType.CALL, self._seqid)
        args = getActivePurchases_args()
        args.start = start
        args.size = size
        args.language = language
        args.country = country
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_getActivePurchases(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = getActivePurchases_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TAsyncioApplicationException(TAsyncioApplicationException.MISSING_RESULT, "getActivePurchases failed: unknown result")

    async def getActivePurchaseVersions(self, start, size, language, country):
        """
        Parameters:
         - start
         - size
         - language
         - country
        """
        await self.send_getActivePurchaseVersions(start, size, language, country)
        return (await self.recv_getActivePurchaseVersions())

    async def send_getActivePurchaseVersions(self, start, size, language, country):
        self._oprot.writeMessageBegin('getActivePurchaseVersions', TMessageType.CALL, self._seqid)
        args = getActivePurchaseVersions_args()
        args.start = start
        args.size = size
        args.language = language
        args.country = country
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_getActivePurchaseVersions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = getActivePurchaseVersions_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TAsyncioApplicationException(TAsyncioApplicationException.MISSING_RESULT, "getActivePurchaseVersions failed: unknown result")

    async def getCoinProducts(self, appStoreCode, country, language):
        """
        Parameters:
         - appStoreCode
         - country
         - language
        """
        await self.send_getCoinProducts(appStoreCode, country, language)
        return (await self.recv_getCoinProducts())

    async def send_getCoinProducts(self, appStoreCode, country, language):
        self._oprot.writeMessageBegin('getCoinProducts', TMessageType.CALL, self._seqid)
        args = getCoinProducts_args()
        args.appStoreCode = appStoreCode
        args.country = country
        args.language = language
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_getCoinProducts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = getCoinProducts_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TAsyncioApplicationException(TAsyncioApplicationException.MISSING_RESULT, "getCoinProducts failed: unknown result")

    async def getCoinProductsByPgCode(self, appStoreCode, pgCode, country, language):
        """
        Parameters:
         - appStoreCode
         - pgCode
         - country
         - language
        """
        await self.send_getCoinProductsByPgCode(appStoreCode, pgCode, country, language)
        return (await self.recv_getCoinProductsByPgCode())

    async def send_getCoinProductsByPgCode(self, appStoreCode, pgCode, country, language):
        self._oprot.writeMessageBegin('getCoinProductsByPgCode', TMessageType.CALL, self._seqid)
        args = getCoinProductsByPgCode_args()
        args.appStoreCode = appStoreCode
        args.pgCode = pgCode
        args.country = country
        args.language = language
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_getCoinProductsByPgCode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = getCoinProductsByPgCode_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TAsyncioApplicationException(TAsyncioApplicationException.MISSING_RESULT, "getCoinProductsByPgCode failed: unknown result")

    async def getCoinPurchaseHistory(self, request):
        """
        Parameters:
         - request
        """
        await self.send_getCoinPurchaseHistory(request)
        return (await self.recv_getCoinPurchaseHistory())

    async def send_getCoinPurchaseHistory(self, request):
        self._oprot.writeMessageBegin('getCoinPurchaseHistory', TMessageType.CALL, self._seqid)
        args = getCoinPurchaseHistory_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_getCoinPurchaseHistory(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = getCoinPurchaseHistory_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TAsyncioApplicationException(TAsyncioApplicationException.MISSING_RESULT, "getCoinPurchaseHistory failed: unknown result")

    async def getCoinUseAndRefundHistory(self, request):
        """
        Parameters:
         - request
        """
        await self.send_getCoinUseAndRefundHistory(request)
        return (await self.recv_getCoinUseAndRefundHistory())

    async def send_getCoinUseAndRefundHistory(self, request):
        self._oprot.writeMessageBegin('getCoinUseAndRefundHistory', TMessageType.CALL, self._seqid)
        args = getCoinUseAndRefundHistory_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_getCoinUseAndRefundHistory(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = getCoinUseAndRefundHistory_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TAsyncioApplicationException(TAsyncioApplicationException.MISSING_RESULT, "getCoinUseAndRefundHistory failed: unknown result")

    async def getDownloads(self, start, size, language, country):
        """
        Parameters:
         - start
         - size
         - language
         - country
        """
        await self.send_getDownloads(start, size, language, country)
        return (await self.recv_getDownloads())

    async def send_getDownloads(self, start, size, language, country):
        self._oprot.writeMessageBegin('getDownloads', TMessageType.CALL, self._seqid)
        args = getDownloads_args()
        args.start = start
        args.size = size
        args.language = language
        args.country = country
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_getDownloads(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = getDownloads_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TAsyncioApplicationException(TAsyncioApplicationException.MISSING_RESULT, "getDownloads failed: unknown result")

    async def getEventPackages(self, start, size, language, country):
        """
        Parameters:
         - start
         - size
         - language
         - country
        """
        await self.send_getEventPackages(start, size, language, country)
        return (await self.recv_getEventPackages())

    async def send_getEventPackages(self, start, size, language, country):
        self._oprot.writeMessageBegin('getEventPackages', TMessageType.CALL, self._seqid)
        args = getEventPackages_args()
        args.start = start
        args.size = size
        args.language = language
        args.country = country
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_getEventPackages(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = getEventPackages_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TAsyncioApplicationException(TAsyncioApplicationException.MISSING_RESULT, "getEventPackages failed: unknown result")

    async def getNewlyReleasedPackages(self, start, size, language, country):
        """
        Parameters:
         - start
         - size
         - language
         - country
        """
        await self.send_getNewlyReleasedPackages(start, size, language, country)
        return (await self.recv_getNewlyReleasedPackages())

    async def send_getNewlyReleasedPackages(self, start, size, language, country):
        self._oprot.writeMessageBegin('getNewlyReleasedPackages', TMessageType.CALL, self._seqid)
        args = getNewlyReleasedPackages_args()
        args.start = start
        args.size = size
        args.language = language
        args.country = country
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_getNewlyReleasedPackages(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = getNewlyReleasedPackages_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TAsyncioApplicationException(TAsyncioApplicationException.MISSING_RESULT, "getNewlyReleasedPackages failed: unknown result")

    async def getPopularPackages(self, start, size, language, country):
        """
        Parameters:
         - start
         - size
         - language
         - country
        """
        await self.send_getPopularPackages(start, size, language, country)
        return (await self.recv_getPopularPackages())

    async def send_getPopularPackages(self, start, size, language, country):
        self._oprot.writeMessageBegin('getPopularPackages', TMessageType.CALL, self._seqid)
        args = getPopularPackages_args()
        args.start = start
        args.size = size
        args.language = language
        args.country = country
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_getPopularPackages(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = getPopularPackages_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TAsyncioApplicationException(TAsyncioApplicationException.MISSING_RESULT, "getPopularPackages failed: unknown result")

    async def getPresentsReceived(self, start, size, language, country):
        """
        Parameters:
         - start
         - size
         - language
         - country
        """
        await self.send_getPresentsReceived(start, size, language, country)
        return (await self.recv_getPresentsReceived())

    async def send_getPresentsReceived(self, start, size, language, country):
        self._oprot.writeMessageBegin('getPresentsReceived', TMessageType.CALL, self._seqid)
        args = getPresentsReceived_args()
        args.start = start
        args.size = size
        args.language = language
        args.country = country
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_getPresentsReceived(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = getPresentsReceived_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TAsyncioApplicationException(TAsyncioApplicationException.MISSING_RESULT, "getPresentsReceived failed: unknown result")

    async def getPresentsSent(self, start, size, language, country):
        """
        Parameters:
         - start
         - size
         - language
         - country
        """
        await self.send_getPresentsSent(start, size, language, country)
        return (await self.recv_getPresentsSent())

    async def send_getPresentsSent(self, start, size, language, country):
        self._oprot.writeMessageBegin('getPresentsSent', TMessageType.CALL, self._seqid)
        args = getPresentsSent_args()
        args.start = start
        args.size = size
        args.language = language
        args.country = country
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_getPresentsSent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = getPresentsSent_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TAsyncioApplicationException(TAsyncioApplicationException.MISSING_RESULT, "getPresentsSent failed: unknown result")

    async def getProduct(self, packageID, language, country):
        """
        Parameters:
         - packageID
         - language
         - country
        """
        await self.send_getProduct(packageID, language, country)
        return (await self.recv_getProduct())

    async def send_getProduct(self, packageID, language, country):
        self._oprot.writeMessageBegin('getProduct', TMessageType.CALL, self._seqid)
        args = getProduct_args()
        args.packageID = packageID
        args.language = language
        args.country = country
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_getProduct(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = getProduct_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TAsyncioApplicationException(TAsyncioApplicationException.MISSING_RESULT, "getProduct failed: unknown result")

    async def getProductList(self, productIdList, language, country):
        """
        Parameters:
         - productIdList
         - language
         - country
        """
        await self.send_getProductList(productIdList, language, country)
        return (await self.recv_getProductList())

    async def send_getProductList(self, productIdList, language, country):
        self._oprot.writeMessageBegin('getProductList', TMessageType.CALL, self._seqid)
        args = getProductList_args()
        args.productIdList = productIdList
        args.language = language
        args.country = country
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_getProductList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = getProductList_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TAsyncioApplicationException(TAsyncioApplicationException.MISSING_RESULT, "getProductList failed: unknown result")

    async def getProductListWithCarrier(self, productIdList, language, country, carrierCode):
        """
        Parameters:
         - productIdList
         - language
         - country
         - carrierCode
        """
        await self.send_getProductListWithCarrier(productIdList, language, country, carrierCode)
        return (await self.recv_getProductListWithCarrier())

    async def send_getProductListWithCarrier(self, productIdList, language, country, carrierCode):
        self._oprot.writeMessageBegin('getProductListWithCarrier', TMessageType.CALL, self._seqid)
        args = getProductListWithCarrier_args()
        args.productIdList = productIdList
        args.language = language
        args.country = country
        args.carrierCode = carrierCode
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_getProductListWithCarrier(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = getProductListWithCarrier_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TAsyncioApplicationException(TAsyncioApplicationException.MISSING_RESULT, "getProductListWithCarrier failed: unknown result")

    async def getProductWithCarrier(self, packageID, language, country, carrierCode):
        """
        Parameters:
         - packageID
         - language
         - country
         - carrierCode
        """
        await self.send_getProductWithCarrier(packageID, language, country, carrierCode)
        return (await self.recv_getProductWithCarrier())

    async def send_getProductWithCarrier(self, packageID, language, country, carrierCode):
        self._oprot.writeMessageBegin('getProductWithCarrier', TMessageType.CALL, self._seqid)
        args = getProductWithCarrier_args()
        args.packageID = packageID
        args.language = language
        args.country = country
        args.carrierCode = carrierCode
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_getProductWithCarrier(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = getProductWithCarrier_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TAsyncioApplicationException(TAsyncioApplicationException.MISSING_RESULT, "getProductWithCarrier failed: unknown result")

    async def getPurchaseHistory(self, start, size, language, country):
        """
        Parameters:
         - start
         - size
         - language
         - country
        """
        await self.send_getPurchaseHistory(start, size, language, country)
        return (await self.recv_getPurchaseHistory())

    async def send_getPurchaseHistory(self, start, size, language, country):
        self._oprot.writeMessageBegin('getPurchaseHistory', TMessageType.CALL, self._seqid)
        args = getPurchaseHistory_args()
        args.start = start
        args.size = size
        args.language = language
        args.country = country
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_getPurchaseHistory(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = getPurchaseHistory_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TAsyncioApplicationException(TAsyncioApplicationException.MISSING_RESULT, "getPurchaseHistory failed: unknown result")

    async def getTotalBalance(self, appStoreCode):
        """
        Parameters:
         - appStoreCode
        """
        await self.send_getTotalBalance(appStoreCode)
        return (await self.recv_getTotalBalance())

    async def send_getTotalBalance(self, appStoreCode):
        self._oprot.writeMessageBegin('getTotalBalance', TMessageType.CALL, self._seqid)
        args = getTotalBalance_args()
        args.appStoreCode = appStoreCode
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_getTotalBalance(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = getTotalBalance_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TAsyncioApplicationException(TAsyncioApplicationException.MISSING_RESULT, "getTotalBalance failed: unknown result")

    async def notifyDownloaded(self, packageId, language):
        """
        Parameters:
         - packageId
         - language
        """
        await self.send_notifyDownloaded(packageId, language)
        return (await self.recv_notifyDownloaded())

    async def send_notifyDownloaded(self, packageId, language):
        self._oprot.writeMessageBegin('notifyDownloaded', TMessageType.CALL, self._seqid)
        args = notifyDownloaded_args()
        args.packageId = packageId
        args.language = language
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_notifyDownloaded(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = notifyDownloaded_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TAsyncioApplicationException(TAsyncioApplicationException.MISSING_RESULT, "notifyDownloaded failed: unknown result")

    async def reserveCoinPurchase(self, request):
        """
        Parameters:
         - request
        """
        await self.send_reserveCoinPurchase(request)
        return (await self.recv_reserveCoinPurchase())

    async def send_reserveCoinPurchase(self, request):
        self._oprot.writeMessageBegin('reserveCoinPurchase', TMessageType.CALL, self._seqid)
        args = reserveCoinPurchase_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_reserveCoinPurchase(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = reserveCoinPurchase_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TAsyncioApplicationException(TAsyncioApplicationException.MISSING_RESULT, "reserveCoinPurchase failed: unknown result")

    async def reservePayment(self, paymentReservation):
        """
        Parameters:
         - paymentReservation
        """
        await self.send_reservePayment(paymentReservation)
        return (await self.recv_reservePayment())

    async def send_reservePayment(self, paymentReservation):
        self._oprot.writeMessageBegin('reservePayment', TMessageType.CALL, self._seqid)
        args = reservePayment_args()
        args.paymentReservation = paymentReservation
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        await self._oprot.trans.flush()

    async def recv_reservePayment(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = await iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TAsyncioApplicationException()
            await x.read(iprot)
            await iprot.readMessageEnd()
            raise x
        result = reservePayment_result()
        await result.read(iprot)
        await iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TAsyncioApplicationException(TAsyncioApplicationException.MISSING_RESULT, "reservePayment failed: unknown result")

# HELPER FUNCTIONS AND STRUCTURES


class buyCoinProduct_args(object):
    """
    Attributes:
     - paymentReservation
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.STRUCT, 'paymentReservation', (PaymentReservation, PaymentReservation.thrift_spec), None, ),  # 2
    )

    def __init__(self, paymentReservation=None,):
        self.paymentReservation = paymentReservation

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.paymentReservation = PaymentReservation()
                    await self.paymentReservation.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('buyCoinProduct_args')
        if self.paymentReservation is not None:
            oprot.writeFieldBegin('paymentReservation', TType.STRUCT, 2)
            self.paymentReservation.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class buyCoinProduct_result(object):
    """
    Attributes:
     - e
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, e=None,):
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('buyCoinProduct_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class buyFreeProduct_args(object):
    """
    Attributes:
     - receiverMid
     - productId
     - messageTemplate
     - language
     - country
     - packageId
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.STRING, 'receiverMid', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'productId', 'UTF8', None, ),  # 3
        (4, TType.I32, 'messageTemplate', None, None, ),  # 4
        (5, TType.STRING, 'language', 'UTF8', None, ),  # 5
        (6, TType.STRING, 'country', 'UTF8', None, ),  # 6
        (7, TType.I64, 'packageId', None, None, ),  # 7
    )

    def __init__(self, receiverMid=None, productId=None, messageTemplate=None, language=None, country=None, packageId=None,):
        self.receiverMid = receiverMid
        self.productId = productId
        self.messageTemplate = messageTemplate
        self.language = language
        self.country = country
        self.packageId = packageId

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.receiverMid = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.productId = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.messageTemplate = await iprot.readI32()
                else:
                    await iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.language = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.country = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.packageId = await iprot.readI64()
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('buyFreeProduct_args')
        if self.receiverMid is not None:
            oprot.writeFieldBegin('receiverMid', TType.STRING, 2)
            oprot.writeString(self.receiverMid)
            oprot.writeFieldEnd()
        if self.productId is not None:
            oprot.writeFieldBegin('productId', TType.STRING, 3)
            oprot.writeString(self.productId)
            oprot.writeFieldEnd()
        if self.messageTemplate is not None:
            oprot.writeFieldBegin('messageTemplate', TType.I32, 4)
            oprot.writeI32(self.messageTemplate)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 5)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        if self.country is not None:
            oprot.writeFieldBegin('country', TType.STRING, 6)
            oprot.writeString(self.country)
            oprot.writeFieldEnd()
        if self.packageId is not None:
            oprot.writeFieldBegin('packageId', TType.I64, 7)
            oprot.writeI64(self.packageId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class buyFreeProduct_result(object):
    """
    Attributes:
     - e
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, e=None,):
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('buyFreeProduct_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class buyMustbuyProduct_args(object):
    """
    Attributes:
     - receiverMid
     - productId
     - messageTemplate
     - language
     - country
     - packageId
     - serialNumber
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.STRING, 'receiverMid', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'productId', 'UTF8', None, ),  # 3
        (4, TType.I32, 'messageTemplate', None, None, ),  # 4
        (5, TType.STRING, 'language', 'UTF8', None, ),  # 5
        (6, TType.STRING, 'country', 'UTF8', None, ),  # 6
        (7, TType.I64, 'packageId', None, None, ),  # 7
        (8, TType.STRING, 'serialNumber', 'UTF8', None, ),  # 8
    )

    def __init__(self, receiverMid=None, productId=None, messageTemplate=None, language=None, country=None, packageId=None, serialNumber=None,):
        self.receiverMid = receiverMid
        self.productId = productId
        self.messageTemplate = messageTemplate
        self.language = language
        self.country = country
        self.packageId = packageId
        self.serialNumber = serialNumber

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.receiverMid = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.productId = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.messageTemplate = await iprot.readI32()
                else:
                    await iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.language = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.country = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.packageId = await iprot.readI64()
                else:
                    await iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.serialNumber = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('buyMustbuyProduct_args')
        if self.receiverMid is not None:
            oprot.writeFieldBegin('receiverMid', TType.STRING, 2)
            oprot.writeString(self.receiverMid)
            oprot.writeFieldEnd()
        if self.productId is not None:
            oprot.writeFieldBegin('productId', TType.STRING, 3)
            oprot.writeString(self.productId)
            oprot.writeFieldEnd()
        if self.messageTemplate is not None:
            oprot.writeFieldBegin('messageTemplate', TType.I32, 4)
            oprot.writeI32(self.messageTemplate)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 5)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        if self.country is not None:
            oprot.writeFieldBegin('country', TType.STRING, 6)
            oprot.writeString(self.country)
            oprot.writeFieldEnd()
        if self.packageId is not None:
            oprot.writeFieldBegin('packageId', TType.I64, 7)
            oprot.writeI64(self.packageId)
            oprot.writeFieldEnd()
        if self.serialNumber is not None:
            oprot.writeFieldBegin('serialNumber', TType.STRING, 8)
            oprot.writeString(self.serialNumber)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class buyMustbuyProduct_result(object):
    """
    Attributes:
     - e
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, e=None,):
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('buyMustbuyProduct_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class checkCanReceivePresent_args(object):
    """
    Attributes:
     - recipientMid
     - packageId
     - language
     - country
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.STRING, 'recipientMid', 'UTF8', None, ),  # 2
        (3, TType.I64, 'packageId', None, None, ),  # 3
        (4, TType.STRING, 'language', 'UTF8', None, ),  # 4
        (5, TType.STRING, 'country', 'UTF8', None, ),  # 5
    )

    def __init__(self, recipientMid=None, packageId=None, language=None, country=None,):
        self.recipientMid = recipientMid
        self.packageId = packageId
        self.language = language
        self.country = country

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.recipientMid = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.packageId = await iprot.readI64()
                else:
                    await iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.language = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.country = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('checkCanReceivePresent_args')
        if self.recipientMid is not None:
            oprot.writeFieldBegin('recipientMid', TType.STRING, 2)
            oprot.writeString(self.recipientMid)
            oprot.writeFieldEnd()
        if self.packageId is not None:
            oprot.writeFieldBegin('packageId', TType.I64, 3)
            oprot.writeI64(self.packageId)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 4)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        if self.country is not None:
            oprot.writeFieldBegin('country', TType.STRING, 5)
            oprot.writeString(self.country)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class checkCanReceivePresent_result(object):
    """
    Attributes:
     - e
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, e=None,):
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('checkCanReceivePresent_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getActivePurchases_args(object):
    """
    Attributes:
     - start
     - size
     - language
     - country
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.I64, 'start', None, None, ),  # 2
        (3, TType.I32, 'size', None, None, ),  # 3
        (4, TType.STRING, 'language', 'UTF8', None, ),  # 4
        (5, TType.STRING, 'country', 'UTF8', None, ),  # 5
    )

    def __init__(self, start=None, size=None, language=None, country=None,):
        self.start = start
        self.size = size
        self.language = language
        self.country = country

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.start = await iprot.readI64()
                else:
                    await iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.size = await iprot.readI32()
                else:
                    await iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.language = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.country = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getActivePurchases_args')
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I64, 2)
            oprot.writeI64(self.start)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 3)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 4)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        if self.country is not None:
            oprot.writeFieldBegin('country', TType.STRING, 5)
            oprot.writeString(self.country)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getActivePurchases_result(object):
    """
    Attributes:
     - success
     - e
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ProductList, ProductList.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ProductList()
                    await self.success.read(iprot)
                else:
                    await iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getActivePurchases_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getActivePurchaseVersions_args(object):
    """
    Attributes:
     - start
     - size
     - language
     - country
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.I64, 'start', None, None, ),  # 2
        (3, TType.I32, 'size', None, None, ),  # 3
        (4, TType.STRING, 'language', 'UTF8', None, ),  # 4
        (5, TType.STRING, 'country', 'UTF8', None, ),  # 5
    )

    def __init__(self, start=None, size=None, language=None, country=None,):
        self.start = start
        self.size = size
        self.language = language
        self.country = country

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.start = await iprot.readI64()
                else:
                    await iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.size = await iprot.readI32()
                else:
                    await iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.language = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.country = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getActivePurchaseVersions_args')
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I64, 2)
            oprot.writeI64(self.start)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 3)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 4)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        if self.country is not None:
            oprot.writeFieldBegin('country', TType.STRING, 5)
            oprot.writeString(self.country)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getActivePurchaseVersions_result(object):
    """
    Attributes:
     - success
     - e
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ProductSimpleList, ProductSimpleList.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ProductSimpleList()
                    await self.success.read(iprot)
                else:
                    await iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getActivePurchaseVersions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getCoinProducts_args(object):
    """
    Attributes:
     - appStoreCode
     - country
     - language
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.I32, 'appStoreCode', None, None, ),  # 2
        (3, TType.STRING, 'country', 'UTF8', None, ),  # 3
        (4, TType.STRING, 'language', 'UTF8', None, ),  # 4
    )

    def __init__(self, appStoreCode=None, country=None, language=None,):
        self.appStoreCode = appStoreCode
        self.country = country
        self.language = language

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.appStoreCode = await iprot.readI32()
                else:
                    await iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.country = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.language = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getCoinProducts_args')
        if self.appStoreCode is not None:
            oprot.writeFieldBegin('appStoreCode', TType.I32, 2)
            oprot.writeI32(self.appStoreCode)
            oprot.writeFieldEnd()
        if self.country is not None:
            oprot.writeFieldBegin('country', TType.STRING, 3)
            oprot.writeString(self.country)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 4)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getCoinProducts_result(object):
    """
    Attributes:
     - success
     - e
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (CoinProductItem, CoinProductItem.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1844, _size1841) = await iprot.readListBegin()
                    for _i1845 in range(_size1841):
                        _elem1846 = CoinProductItem()
                        await _elem1846.read(iprot)
                        self.success.append(_elem1846)
                    await iprot.readListEnd()
                else:
                    await iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getCoinProducts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1847 in self.success:
                iter1847.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getCoinProductsByPgCode_args(object):
    """
    Attributes:
     - appStoreCode
     - pgCode
     - country
     - language
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.I32, 'appStoreCode', None, None, ),  # 2
        (3, TType.I32, 'pgCode', None, None, ),  # 3
        (4, TType.STRING, 'country', 'UTF8', None, ),  # 4
        (5, TType.STRING, 'language', 'UTF8', None, ),  # 5
    )

    def __init__(self, appStoreCode=None, pgCode=None, country=None, language=None,):
        self.appStoreCode = appStoreCode
        self.pgCode = pgCode
        self.country = country
        self.language = language

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.appStoreCode = await iprot.readI32()
                else:
                    await iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.pgCode = await iprot.readI32()
                else:
                    await iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.country = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.language = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getCoinProductsByPgCode_args')
        if self.appStoreCode is not None:
            oprot.writeFieldBegin('appStoreCode', TType.I32, 2)
            oprot.writeI32(self.appStoreCode)
            oprot.writeFieldEnd()
        if self.pgCode is not None:
            oprot.writeFieldBegin('pgCode', TType.I32, 3)
            oprot.writeI32(self.pgCode)
            oprot.writeFieldEnd()
        if self.country is not None:
            oprot.writeFieldBegin('country', TType.STRING, 4)
            oprot.writeString(self.country)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 5)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getCoinProductsByPgCode_result(object):
    """
    Attributes:
     - success
     - e
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (CoinProductItem, CoinProductItem.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1851, _size1848) = await iprot.readListBegin()
                    for _i1852 in range(_size1848):
                        _elem1853 = CoinProductItem()
                        await _elem1853.read(iprot)
                        self.success.append(_elem1853)
                    await iprot.readListEnd()
                else:
                    await iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getCoinProductsByPgCode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1854 in self.success:
                iter1854.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getCoinPurchaseHistory_args(object):
    """
    Attributes:
     - request
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.STRUCT, 'request', (CoinHistoryCondition, CoinHistoryCondition.thrift_spec), None, ),  # 2
    )

    def __init__(self, request=None,):
        self.request = request

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.request = CoinHistoryCondition()
                    await self.request.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getCoinPurchaseHistory_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 2)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getCoinPurchaseHistory_result(object):
    """
    Attributes:
     - success
     - e
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (CoinHistoryResult, CoinHistoryResult.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CoinHistoryResult()
                    await self.success.read(iprot)
                else:
                    await iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getCoinPurchaseHistory_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getCoinUseAndRefundHistory_args(object):
    """
    Attributes:
     - request
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.STRUCT, 'request', (CoinHistoryCondition, CoinHistoryCondition.thrift_spec), None, ),  # 2
    )

    def __init__(self, request=None,):
        self.request = request

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.request = CoinHistoryCondition()
                    await self.request.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getCoinUseAndRefundHistory_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 2)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getCoinUseAndRefundHistory_result(object):
    """
    Attributes:
     - success
     - e
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (CoinHistoryResult, CoinHistoryResult.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CoinHistoryResult()
                    await self.success.read(iprot)
                else:
                    await iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getCoinUseAndRefundHistory_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getDownloads_args(object):
    """
    Attributes:
     - start
     - size
     - language
     - country
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.I64, 'start', None, None, ),  # 2
        (3, TType.I32, 'size', None, None, ),  # 3
        (4, TType.STRING, 'language', 'UTF8', None, ),  # 4
        (5, TType.STRING, 'country', 'UTF8', None, ),  # 5
    )

    def __init__(self, start=None, size=None, language=None, country=None,):
        self.start = start
        self.size = size
        self.language = language
        self.country = country

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.start = await iprot.readI64()
                else:
                    await iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.size = await iprot.readI32()
                else:
                    await iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.language = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.country = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getDownloads_args')
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I64, 2)
            oprot.writeI64(self.start)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 3)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 4)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        if self.country is not None:
            oprot.writeFieldBegin('country', TType.STRING, 5)
            oprot.writeString(self.country)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getDownloads_result(object):
    """
    Attributes:
     - success
     - e
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ProductList, ProductList.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ProductList()
                    await self.success.read(iprot)
                else:
                    await iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getDownloads_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getEventPackages_args(object):
    """
    Attributes:
     - start
     - size
     - language
     - country
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.I64, 'start', None, None, ),  # 2
        (3, TType.I32, 'size', None, None, ),  # 3
        (4, TType.STRING, 'language', 'UTF8', None, ),  # 4
        (5, TType.STRING, 'country', 'UTF8', None, ),  # 5
    )

    def __init__(self, start=None, size=None, language=None, country=None,):
        self.start = start
        self.size = size
        self.language = language
        self.country = country

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.start = await iprot.readI64()
                else:
                    await iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.size = await iprot.readI32()
                else:
                    await iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.language = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.country = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getEventPackages_args')
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I64, 2)
            oprot.writeI64(self.start)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 3)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 4)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        if self.country is not None:
            oprot.writeFieldBegin('country', TType.STRING, 5)
            oprot.writeString(self.country)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getEventPackages_result(object):
    """
    Attributes:
     - success
     - e
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ProductList, ProductList.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ProductList()
                    await self.success.read(iprot)
                else:
                    await iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getEventPackages_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getNewlyReleasedPackages_args(object):
    """
    Attributes:
     - start
     - size
     - language
     - country
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.I64, 'start', None, None, ),  # 2
        (3, TType.I32, 'size', None, None, ),  # 3
        (4, TType.STRING, 'language', 'UTF8', None, ),  # 4
        (5, TType.STRING, 'country', 'UTF8', None, ),  # 5
    )

    def __init__(self, start=None, size=None, language=None, country=None,):
        self.start = start
        self.size = size
        self.language = language
        self.country = country

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.start = await iprot.readI64()
                else:
                    await iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.size = await iprot.readI32()
                else:
                    await iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.language = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.country = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getNewlyReleasedPackages_args')
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I64, 2)
            oprot.writeI64(self.start)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 3)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 4)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        if self.country is not None:
            oprot.writeFieldBegin('country', TType.STRING, 5)
            oprot.writeString(self.country)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getNewlyReleasedPackages_result(object):
    """
    Attributes:
     - success
     - e
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ProductList, ProductList.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ProductList()
                    await self.success.read(iprot)
                else:
                    await iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getNewlyReleasedPackages_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getPopularPackages_args(object):
    """
    Attributes:
     - start
     - size
     - language
     - country
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.I64, 'start', None, None, ),  # 2
        (3, TType.I32, 'size', None, None, ),  # 3
        (4, TType.STRING, 'language', 'UTF8', None, ),  # 4
        (5, TType.STRING, 'country', 'UTF8', None, ),  # 5
    )

    def __init__(self, start=None, size=None, language=None, country=None,):
        self.start = start
        self.size = size
        self.language = language
        self.country = country

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.start = await iprot.readI64()
                else:
                    await iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.size = await iprot.readI32()
                else:
                    await iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.language = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.country = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getPopularPackages_args')
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I64, 2)
            oprot.writeI64(self.start)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 3)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 4)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        if self.country is not None:
            oprot.writeFieldBegin('country', TType.STRING, 5)
            oprot.writeString(self.country)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getPopularPackages_result(object):
    """
    Attributes:
     - success
     - e
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ProductList, ProductList.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ProductList()
                    await self.success.read(iprot)
                else:
                    await iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getPopularPackages_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getPresentsReceived_args(object):
    """
    Attributes:
     - start
     - size
     - language
     - country
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.I64, 'start', None, None, ),  # 2
        (3, TType.I32, 'size', None, None, ),  # 3
        (4, TType.STRING, 'language', 'UTF8', None, ),  # 4
        (5, TType.STRING, 'country', 'UTF8', None, ),  # 5
    )

    def __init__(self, start=None, size=None, language=None, country=None,):
        self.start = start
        self.size = size
        self.language = language
        self.country = country

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.start = await iprot.readI64()
                else:
                    await iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.size = await iprot.readI32()
                else:
                    await iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.language = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.country = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getPresentsReceived_args')
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I64, 2)
            oprot.writeI64(self.start)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 3)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 4)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        if self.country is not None:
            oprot.writeFieldBegin('country', TType.STRING, 5)
            oprot.writeString(self.country)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getPresentsReceived_result(object):
    """
    Attributes:
     - success
     - e
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ProductList, ProductList.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ProductList()
                    await self.success.read(iprot)
                else:
                    await iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getPresentsReceived_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getPresentsSent_args(object):
    """
    Attributes:
     - start
     - size
     - language
     - country
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.I64, 'start', None, None, ),  # 2
        (3, TType.I32, 'size', None, None, ),  # 3
        (4, TType.STRING, 'language', 'UTF8', None, ),  # 4
        (5, TType.STRING, 'country', 'UTF8', None, ),  # 5
    )

    def __init__(self, start=None, size=None, language=None, country=None,):
        self.start = start
        self.size = size
        self.language = language
        self.country = country

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.start = await iprot.readI64()
                else:
                    await iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.size = await iprot.readI32()
                else:
                    await iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.language = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.country = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getPresentsSent_args')
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I64, 2)
            oprot.writeI64(self.start)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 3)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 4)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        if self.country is not None:
            oprot.writeFieldBegin('country', TType.STRING, 5)
            oprot.writeString(self.country)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getPresentsSent_result(object):
    """
    Attributes:
     - success
     - e
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ProductList, ProductList.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ProductList()
                    await self.success.read(iprot)
                else:
                    await iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getPresentsSent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getProduct_args(object):
    """
    Attributes:
     - packageID
     - language
     - country
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.I64, 'packageID', None, None, ),  # 2
        (3, TType.STRING, 'language', 'UTF8', None, ),  # 3
        (4, TType.STRING, 'country', 'UTF8', None, ),  # 4
    )

    def __init__(self, packageID=None, language=None, country=None,):
        self.packageID = packageID
        self.language = language
        self.country = country

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.packageID = await iprot.readI64()
                else:
                    await iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.language = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.country = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getProduct_args')
        if self.packageID is not None:
            oprot.writeFieldBegin('packageID', TType.I64, 2)
            oprot.writeI64(self.packageID)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 3)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        if self.country is not None:
            oprot.writeFieldBegin('country', TType.STRING, 4)
            oprot.writeString(self.country)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getProduct_result(object):
    """
    Attributes:
     - success
     - e
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (Product, Product.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Product()
                    await self.success.read(iprot)
                else:
                    await iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getProduct_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getProductList_args(object):
    """
    Attributes:
     - productIdList
     - language
     - country
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.LIST, 'productIdList', (TType.STRING, 'UTF8', False), None, ),  # 2
        (3, TType.STRING, 'language', 'UTF8', None, ),  # 3
        (4, TType.STRING, 'country', 'UTF8', None, ),  # 4
    )

    def __init__(self, productIdList=None, language=None, country=None,):
        self.productIdList = productIdList
        self.language = language
        self.country = country

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.LIST:
                    self.productIdList = []
                    (_etype1858, _size1855) = await iprot.readListBegin()
                    for _i1859 in range(_size1855):
                        _elem1860 = await iprot.readString()
                        self.productIdList.append(_elem1860)
                    await iprot.readListEnd()
                else:
                    await iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.language = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.country = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getProductList_args')
        if self.productIdList is not None:
            oprot.writeFieldBegin('productIdList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.productIdList))
            for iter1861 in self.productIdList:
                oprot.writeString(iter1861)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 3)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        if self.country is not None:
            oprot.writeFieldBegin('country', TType.STRING, 4)
            oprot.writeString(self.country)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getProductList_result(object):
    """
    Attributes:
     - success
     - e
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ProductList, ProductList.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ProductList()
                    await self.success.read(iprot)
                else:
                    await iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getProductList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getProductListWithCarrier_args(object):
    """
    Attributes:
     - productIdList
     - language
     - country
     - carrierCode
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.LIST, 'productIdList', (TType.STRING, 'UTF8', False), None, ),  # 2
        (3, TType.STRING, 'language', 'UTF8', None, ),  # 3
        (4, TType.STRING, 'country', 'UTF8', None, ),  # 4
        (5, TType.STRING, 'carrierCode', 'UTF8', None, ),  # 5
    )

    def __init__(self, productIdList=None, language=None, country=None, carrierCode=None,):
        self.productIdList = productIdList
        self.language = language
        self.country = country
        self.carrierCode = carrierCode

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.LIST:
                    self.productIdList = []
                    (_etype1865, _size1862) = await iprot.readListBegin()
                    for _i1866 in range(_size1862):
                        _elem1867 = await iprot.readString()
                        self.productIdList.append(_elem1867)
                    await iprot.readListEnd()
                else:
                    await iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.language = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.country = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.carrierCode = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getProductListWithCarrier_args')
        if self.productIdList is not None:
            oprot.writeFieldBegin('productIdList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.productIdList))
            for iter1868 in self.productIdList:
                oprot.writeString(iter1868)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 3)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        if self.country is not None:
            oprot.writeFieldBegin('country', TType.STRING, 4)
            oprot.writeString(self.country)
            oprot.writeFieldEnd()
        if self.carrierCode is not None:
            oprot.writeFieldBegin('carrierCode', TType.STRING, 5)
            oprot.writeString(self.carrierCode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getProductListWithCarrier_result(object):
    """
    Attributes:
     - success
     - e
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ProductList, ProductList.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ProductList()
                    await self.success.read(iprot)
                else:
                    await iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getProductListWithCarrier_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getProductWithCarrier_args(object):
    """
    Attributes:
     - packageID
     - language
     - country
     - carrierCode
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.I64, 'packageID', None, None, ),  # 2
        (3, TType.STRING, 'language', 'UTF8', None, ),  # 3
        (4, TType.STRING, 'country', 'UTF8', None, ),  # 4
        (5, TType.STRING, 'carrierCode', 'UTF8', None, ),  # 5
    )

    def __init__(self, packageID=None, language=None, country=None, carrierCode=None,):
        self.packageID = packageID
        self.language = language
        self.country = country
        self.carrierCode = carrierCode

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.packageID = await iprot.readI64()
                else:
                    await iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.language = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.country = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.carrierCode = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getProductWithCarrier_args')
        if self.packageID is not None:
            oprot.writeFieldBegin('packageID', TType.I64, 2)
            oprot.writeI64(self.packageID)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 3)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        if self.country is not None:
            oprot.writeFieldBegin('country', TType.STRING, 4)
            oprot.writeString(self.country)
            oprot.writeFieldEnd()
        if self.carrierCode is not None:
            oprot.writeFieldBegin('carrierCode', TType.STRING, 5)
            oprot.writeString(self.carrierCode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getProductWithCarrier_result(object):
    """
    Attributes:
     - success
     - e
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (Product, Product.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Product()
                    await self.success.read(iprot)
                else:
                    await iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getProductWithCarrier_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getPurchaseHistory_args(object):
    """
    Attributes:
     - start
     - size
     - language
     - country
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.I64, 'start', None, None, ),  # 2
        (3, TType.I32, 'size', None, None, ),  # 3
        (4, TType.STRING, 'language', 'UTF8', None, ),  # 4
        (5, TType.STRING, 'country', 'UTF8', None, ),  # 5
    )

    def __init__(self, start=None, size=None, language=None, country=None,):
        self.start = start
        self.size = size
        self.language = language
        self.country = country

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.start = await iprot.readI64()
                else:
                    await iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.size = await iprot.readI32()
                else:
                    await iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.language = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.country = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getPurchaseHistory_args')
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I64, 2)
            oprot.writeI64(self.start)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 3)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 4)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        if self.country is not None:
            oprot.writeFieldBegin('country', TType.STRING, 5)
            oprot.writeString(self.country)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getPurchaseHistory_result(object):
    """
    Attributes:
     - success
     - e
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ProductList, ProductList.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ProductList()
                    await self.success.read(iprot)
                else:
                    await iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getPurchaseHistory_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getTotalBalance_args(object):
    """
    Attributes:
     - appStoreCode
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.I32, 'appStoreCode', None, None, ),  # 2
    )

    def __init__(self, appStoreCode=None,):
        self.appStoreCode = appStoreCode

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.appStoreCode = await iprot.readI32()
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getTotalBalance_args')
        if self.appStoreCode is not None:
            oprot.writeFieldBegin('appStoreCode', TType.I32, 2)
            oprot.writeI32(self.appStoreCode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getTotalBalance_result(object):
    """
    Attributes:
     - success
     - e
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (Coin, Coin.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Coin()
                    await self.success.read(iprot)
                else:
                    await iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getTotalBalance_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class notifyDownloaded_args(object):
    """
    Attributes:
     - packageId
     - language
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.I64, 'packageId', None, None, ),  # 2
        (3, TType.STRING, 'language', 'UTF8', None, ),  # 3
    )

    def __init__(self, packageId=None, language=None,):
        self.packageId = packageId
        self.language = language

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.packageId = await iprot.readI64()
                else:
                    await iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.language = await iprot.readString()
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('notifyDownloaded_args')
        if self.packageId is not None:
            oprot.writeFieldBegin('packageId', TType.I64, 2)
            oprot.writeI64(self.packageId)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 3)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class notifyDownloaded_result(object):
    """
    Attributes:
     - success
     - e
    """

    thrift_spec = (
        (0, TType.I64, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = await iprot.readI64()
                else:
                    await iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('notifyDownloaded_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class reserveCoinPurchase_args(object):
    """
    Attributes:
     - request
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.STRUCT, 'request', (CoinPurchaseReservation, CoinPurchaseReservation.thrift_spec), None, ),  # 2
    )

    def __init__(self, request=None,):
        self.request = request

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.request = CoinPurchaseReservation()
                    await self.request.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('reserveCoinPurchase_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 2)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class reserveCoinPurchase_result(object):
    """
    Attributes:
     - success
     - e
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (PaymentReservationResult, PaymentReservationResult.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PaymentReservationResult()
                    await self.success.read(iprot)
                else:
                    await iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('reserveCoinPurchase_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class reservePayment_args(object):
    """
    Attributes:
     - paymentReservation
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.STRUCT, 'paymentReservation', (PaymentReservation, PaymentReservation.thrift_spec), None, ),  # 2
    )

    def __init__(self, paymentReservation=None,):
        self.paymentReservation = paymentReservation

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.paymentReservation = PaymentReservation()
                    await self.paymentReservation.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('reservePayment_args')
        if self.paymentReservation is not None:
            oprot.writeFieldBegin('paymentReservation', TType.STRUCT, 2)
            self.paymentReservation.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class reservePayment_result(object):
    """
    Attributes:
     - success
     - e
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (PaymentReservationResult, PaymentReservationResult.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    async def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        await iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = await iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PaymentReservationResult()
                    await self.success.read(iprot)
                else:
                    await iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    await self.e.read(iprot)
                else:
                    await iprot.skip(ftype)
            else:
                await iprot.skip(ftype)
            await iprot.readFieldEnd()
        await iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('reservePayment_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
